// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rockset

import (
	"context"
	"reflect"

	"errors"
	"github.com/ddn0/pulumi-rockset/sdk/go/rockset/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a collection created from a Kafka source. The `useV3` field must match the integration which the collection is created from.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/ddn0/pulumi-rockset/sdk/go/rockset"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			bootstrapServers := cfg.RequireObject("bootstrapServers")
//			apikey := cfg.RequireObject("apikey")
//			secret := cfg.RequireObject("secret")
//			confluentKafkaIntegration, err := rockset.NewKafkaIntegration(ctx, "confluentKafkaIntegration", &rockset.KafkaIntegrationArgs{
//				Description:      pulumi.String("Integration to ingest documents from Confluent Cloud"),
//				UseV3:            pulumi.Bool(true),
//				BootstrapServers: pulumi.Any(bootstrapServers),
//				SecurityConfig: pulumi.StringMap{
//					"api_key": pulumi.Any(apikey),
//					"secret":  pulumi.Any(secret),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			confluentWorkspace, err := rockset.NewWorkspace(ctx, "confluentWorkspace", &rockset.WorkspaceArgs{
//				Description: pulumi.String("Collections from Confluent Cloud topics."),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = rockset.NewKafkaCollection(ctx, "test", &rockset.KafkaCollectionArgs{
//				Workspace:     confluentWorkspace.Name,
//				Description:   pulumi.String("Collection from a Confluent Cloud topic."),
//				RetentionSecs: pulumi.Int(3600),
//				Sources: rockset.KafkaCollectionSourceArray{
//					&rockset.KafkaCollectionSourceArgs{
//						IntegrationName:   confluentKafkaIntegration.Name,
//						UseV3:             pulumi.Bool(true),
//						TopicName:         pulumi.String("test_json"),
//						OffsetResetPolicy: pulumi.String("EARLIEST"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type KafkaCollection struct {
	pulumi.CustomResourceState

	// Text describing the collection.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation pulumi.StringPtrOutput `pulumi:"ingestTransformation"`
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name pulumi.StringOutput `pulumi:"name"`
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs pulumi.IntPtrOutput `pulumi:"retentionSecs"`
	// Defines a source for this collection.
	Sources KafkaCollectionSourceArrayOutput `pulumi:"sources"`
	// Wait until the collection is ready.
	WaitForCollection pulumi.BoolPtrOutput `pulumi:"waitForCollection"`
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments pulumi.IntPtrOutput `pulumi:"waitForDocuments"`
	// The name of the workspace.
	Workspace pulumi.StringOutput `pulumi:"workspace"`
}

// NewKafkaCollection registers a new resource with the given unique name, arguments, and options.
func NewKafkaCollection(ctx *pulumi.Context,
	name string, args *KafkaCollectionArgs, opts ...pulumi.ResourceOption) (*KafkaCollection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Workspace == nil {
		return nil, errors.New("invalid value for required argument 'Workspace'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KafkaCollection
	err := ctx.RegisterResource("rockset:index/kafkaCollection:KafkaCollection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKafkaCollection gets an existing KafkaCollection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKafkaCollection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KafkaCollectionState, opts ...pulumi.ResourceOption) (*KafkaCollection, error) {
	var resource KafkaCollection
	err := ctx.ReadResource("rockset:index/kafkaCollection:KafkaCollection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KafkaCollection resources.
type kafkaCollectionState struct {
	// Text describing the collection.
	Description *string `pulumi:"description"`
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation *string `pulumi:"ingestTransformation"`
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs *int `pulumi:"retentionSecs"`
	// Defines a source for this collection.
	Sources []KafkaCollectionSource `pulumi:"sources"`
	// Wait until the collection is ready.
	WaitForCollection *bool `pulumi:"waitForCollection"`
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments *int `pulumi:"waitForDocuments"`
	// The name of the workspace.
	Workspace *string `pulumi:"workspace"`
}

type KafkaCollectionState struct {
	// Text describing the collection.
	Description pulumi.StringPtrInput
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation pulumi.StringPtrInput
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs pulumi.IntPtrInput
	// Defines a source for this collection.
	Sources KafkaCollectionSourceArrayInput
	// Wait until the collection is ready.
	WaitForCollection pulumi.BoolPtrInput
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments pulumi.IntPtrInput
	// The name of the workspace.
	Workspace pulumi.StringPtrInput
}

func (KafkaCollectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*kafkaCollectionState)(nil)).Elem()
}

type kafkaCollectionArgs struct {
	// Text describing the collection.
	Description *string `pulumi:"description"`
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation *string `pulumi:"ingestTransformation"`
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs *int `pulumi:"retentionSecs"`
	// Defines a source for this collection.
	Sources []KafkaCollectionSource `pulumi:"sources"`
	// Wait until the collection is ready.
	WaitForCollection *bool `pulumi:"waitForCollection"`
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments *int `pulumi:"waitForDocuments"`
	// The name of the workspace.
	Workspace string `pulumi:"workspace"`
}

// The set of arguments for constructing a KafkaCollection resource.
type KafkaCollectionArgs struct {
	// Text describing the collection.
	Description pulumi.StringPtrInput
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation pulumi.StringPtrInput
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs pulumi.IntPtrInput
	// Defines a source for this collection.
	Sources KafkaCollectionSourceArrayInput
	// Wait until the collection is ready.
	WaitForCollection pulumi.BoolPtrInput
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments pulumi.IntPtrInput
	// The name of the workspace.
	Workspace pulumi.StringInput
}

func (KafkaCollectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kafkaCollectionArgs)(nil)).Elem()
}

type KafkaCollectionInput interface {
	pulumi.Input

	ToKafkaCollectionOutput() KafkaCollectionOutput
	ToKafkaCollectionOutputWithContext(ctx context.Context) KafkaCollectionOutput
}

func (*KafkaCollection) ElementType() reflect.Type {
	return reflect.TypeOf((**KafkaCollection)(nil)).Elem()
}

func (i *KafkaCollection) ToKafkaCollectionOutput() KafkaCollectionOutput {
	return i.ToKafkaCollectionOutputWithContext(context.Background())
}

func (i *KafkaCollection) ToKafkaCollectionOutputWithContext(ctx context.Context) KafkaCollectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaCollectionOutput)
}

// KafkaCollectionArrayInput is an input type that accepts KafkaCollectionArray and KafkaCollectionArrayOutput values.
// You can construct a concrete instance of `KafkaCollectionArrayInput` via:
//
//	KafkaCollectionArray{ KafkaCollectionArgs{...} }
type KafkaCollectionArrayInput interface {
	pulumi.Input

	ToKafkaCollectionArrayOutput() KafkaCollectionArrayOutput
	ToKafkaCollectionArrayOutputWithContext(context.Context) KafkaCollectionArrayOutput
}

type KafkaCollectionArray []KafkaCollectionInput

func (KafkaCollectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KafkaCollection)(nil)).Elem()
}

func (i KafkaCollectionArray) ToKafkaCollectionArrayOutput() KafkaCollectionArrayOutput {
	return i.ToKafkaCollectionArrayOutputWithContext(context.Background())
}

func (i KafkaCollectionArray) ToKafkaCollectionArrayOutputWithContext(ctx context.Context) KafkaCollectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaCollectionArrayOutput)
}

// KafkaCollectionMapInput is an input type that accepts KafkaCollectionMap and KafkaCollectionMapOutput values.
// You can construct a concrete instance of `KafkaCollectionMapInput` via:
//
//	KafkaCollectionMap{ "key": KafkaCollectionArgs{...} }
type KafkaCollectionMapInput interface {
	pulumi.Input

	ToKafkaCollectionMapOutput() KafkaCollectionMapOutput
	ToKafkaCollectionMapOutputWithContext(context.Context) KafkaCollectionMapOutput
}

type KafkaCollectionMap map[string]KafkaCollectionInput

func (KafkaCollectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KafkaCollection)(nil)).Elem()
}

func (i KafkaCollectionMap) ToKafkaCollectionMapOutput() KafkaCollectionMapOutput {
	return i.ToKafkaCollectionMapOutputWithContext(context.Background())
}

func (i KafkaCollectionMap) ToKafkaCollectionMapOutputWithContext(ctx context.Context) KafkaCollectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaCollectionMapOutput)
}

type KafkaCollectionOutput struct{ *pulumi.OutputState }

func (KafkaCollectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KafkaCollection)(nil)).Elem()
}

func (o KafkaCollectionOutput) ToKafkaCollectionOutput() KafkaCollectionOutput {
	return o
}

func (o KafkaCollectionOutput) ToKafkaCollectionOutputWithContext(ctx context.Context) KafkaCollectionOutput {
	return o
}

// Text describing the collection.
func (o KafkaCollectionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Ingest transformation SQL query. Turns the collection into insertOnly mode.
func (o KafkaCollectionOutput) IngestTransformation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.StringPtrOutput { return v.IngestTransformation }).(pulumi.StringPtrOutput)
}

// Unique identifier for the collection. Can contain alphanumeric or dash characters.
func (o KafkaCollectionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Number of seconds after which data is purged. Based on event time.
func (o KafkaCollectionOutput) RetentionSecs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.IntPtrOutput { return v.RetentionSecs }).(pulumi.IntPtrOutput)
}

// Defines a source for this collection.
func (o KafkaCollectionOutput) Sources() KafkaCollectionSourceArrayOutput {
	return o.ApplyT(func(v *KafkaCollection) KafkaCollectionSourceArrayOutput { return v.Sources }).(KafkaCollectionSourceArrayOutput)
}

// Wait until the collection is ready.
func (o KafkaCollectionOutput) WaitForCollection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.BoolPtrOutput { return v.WaitForCollection }).(pulumi.BoolPtrOutput)
}

// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
func (o KafkaCollectionOutput) WaitForDocuments() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.IntPtrOutput { return v.WaitForDocuments }).(pulumi.IntPtrOutput)
}

// The name of the workspace.
func (o KafkaCollectionOutput) Workspace() pulumi.StringOutput {
	return o.ApplyT(func(v *KafkaCollection) pulumi.StringOutput { return v.Workspace }).(pulumi.StringOutput)
}

type KafkaCollectionArrayOutput struct{ *pulumi.OutputState }

func (KafkaCollectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KafkaCollection)(nil)).Elem()
}

func (o KafkaCollectionArrayOutput) ToKafkaCollectionArrayOutput() KafkaCollectionArrayOutput {
	return o
}

func (o KafkaCollectionArrayOutput) ToKafkaCollectionArrayOutputWithContext(ctx context.Context) KafkaCollectionArrayOutput {
	return o
}

func (o KafkaCollectionArrayOutput) Index(i pulumi.IntInput) KafkaCollectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KafkaCollection {
		return vs[0].([]*KafkaCollection)[vs[1].(int)]
	}).(KafkaCollectionOutput)
}

type KafkaCollectionMapOutput struct{ *pulumi.OutputState }

func (KafkaCollectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KafkaCollection)(nil)).Elem()
}

func (o KafkaCollectionMapOutput) ToKafkaCollectionMapOutput() KafkaCollectionMapOutput {
	return o
}

func (o KafkaCollectionMapOutput) ToKafkaCollectionMapOutputWithContext(ctx context.Context) KafkaCollectionMapOutput {
	return o
}

func (o KafkaCollectionMapOutput) MapIndex(k pulumi.StringInput) KafkaCollectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KafkaCollection {
		return vs[0].(map[string]*KafkaCollection)[vs[1].(string)]
	}).(KafkaCollectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaCollectionInput)(nil)).Elem(), &KafkaCollection{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaCollectionArrayInput)(nil)).Elem(), KafkaCollectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaCollectionMapInput)(nil)).Elem(), KafkaCollectionMap{})
	pulumi.RegisterOutputType(KafkaCollectionOutput{})
	pulumi.RegisterOutputType(KafkaCollectionArrayOutput{})
	pulumi.RegisterOutputType(KafkaCollectionMapOutput{})
}
