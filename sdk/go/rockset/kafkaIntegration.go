// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rockset

import (
	"context"
	"reflect"

	"github.com/ddn0/pulumi-rockset/sdk/go/rockset/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/ddn0/pulumi-rockset/sdk/go/rockset"
//	"github.com/pulumi/pulumi-null/sdk/go/null"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			rocksetApiserver := "https://api.usw2a1.rockset.com"
//			if param := cfg.Get("rocksetApiserver"); param != "" {
//				rocksetApiserver = param
//			}
//			kafkaConnect := "localhost:8083"
//			if param := cfg.Get("kafkaConnect"); param != "" {
//				kafkaConnect = param
//			}
//			topics := cfg.RequireObject("topics")
//			maxTasks := float64(10)
//			if param := cfg.GetFloat64("maxTasks"); param != 0 {
//				maxTasks = param
//			}
//			_, err := rockset.NewKafkaIntegration(ctx, "local", &rockset.KafkaIntegrationArgs{
//				Description:     pulumi.String("Integration to ingest from a local kafka."),
//				KafkaDataFormat: pulumi.String("JSON"),
//				KafkaTopicNames: pulumi.StringArray{
//					pulumi.String("foo"),
//					pulumi.String("bar"),
//				},
//				WaitForIntegration: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = null.NewResource(ctx, "configure-kafka-connect", nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type KafkaIntegration struct {
	pulumi.CustomResourceState

	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers pulumi.StringPtrOutput `pulumi:"bootstrapServers"`
	// Kafka connection string.
	ConnectionString pulumi.StringOutput `pulumi:"connectionString"`
	// Text describing the integration.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat pulumi.StringPtrOutput `pulumi:"kafkaDataFormat"`
	// Kafka topics to tail.
	KafkaTopicNames pulumi.StringArrayOutput `pulumi:"kafkaTopicNames"`
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name pulumi.StringOutput `pulumi:"name"`
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig pulumi.StringMapOutput `pulumi:"schemaRegistryConfig"`
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig pulumi.StringMapOutput `pulumi:"securityConfig"`
	// Use v3 for Confluent Cloud.
	UseV3 pulumi.BoolPtrOutput `pulumi:"useV3"`
	// Wait until the integration is active.
	WaitForIntegration pulumi.BoolPtrOutput `pulumi:"waitForIntegration"`
}

// NewKafkaIntegration registers a new resource with the given unique name, arguments, and options.
func NewKafkaIntegration(ctx *pulumi.Context,
	name string, args *KafkaIntegrationArgs, opts ...pulumi.ResourceOption) (*KafkaIntegration, error) {
	if args == nil {
		args = &KafkaIntegrationArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KafkaIntegration
	err := ctx.RegisterResource("rockset:index/kafkaIntegration:KafkaIntegration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKafkaIntegration gets an existing KafkaIntegration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKafkaIntegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KafkaIntegrationState, opts ...pulumi.ResourceOption) (*KafkaIntegration, error) {
	var resource KafkaIntegration
	err := ctx.ReadResource("rockset:index/kafkaIntegration:KafkaIntegration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KafkaIntegration resources.
type kafkaIntegrationState struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers *string `pulumi:"bootstrapServers"`
	// Kafka connection string.
	ConnectionString *string `pulumi:"connectionString"`
	// Text describing the integration.
	Description *string `pulumi:"description"`
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat *string `pulumi:"kafkaDataFormat"`
	// Kafka topics to tail.
	KafkaTopicNames []string `pulumi:"kafkaTopicNames"`
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig map[string]string `pulumi:"schemaRegistryConfig"`
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig map[string]string `pulumi:"securityConfig"`
	// Use v3 for Confluent Cloud.
	UseV3 *bool `pulumi:"useV3"`
	// Wait until the integration is active.
	WaitForIntegration *bool `pulumi:"waitForIntegration"`
}

type KafkaIntegrationState struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers pulumi.StringPtrInput
	// Kafka connection string.
	ConnectionString pulumi.StringPtrInput
	// Text describing the integration.
	Description pulumi.StringPtrInput
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat pulumi.StringPtrInput
	// Kafka topics to tail.
	KafkaTopicNames pulumi.StringArrayInput
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig pulumi.StringMapInput
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig pulumi.StringMapInput
	// Use v3 for Confluent Cloud.
	UseV3 pulumi.BoolPtrInput
	// Wait until the integration is active.
	WaitForIntegration pulumi.BoolPtrInput
}

func (KafkaIntegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*kafkaIntegrationState)(nil)).Elem()
}

type kafkaIntegrationArgs struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers *string `pulumi:"bootstrapServers"`
	// Kafka connection string.
	ConnectionString *string `pulumi:"connectionString"`
	// Text describing the integration.
	Description *string `pulumi:"description"`
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat *string `pulumi:"kafkaDataFormat"`
	// Kafka topics to tail.
	KafkaTopicNames []string `pulumi:"kafkaTopicNames"`
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig map[string]string `pulumi:"schemaRegistryConfig"`
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig map[string]string `pulumi:"securityConfig"`
	// Use v3 for Confluent Cloud.
	UseV3 *bool `pulumi:"useV3"`
	// Wait until the integration is active.
	WaitForIntegration *bool `pulumi:"waitForIntegration"`
}

// The set of arguments for constructing a KafkaIntegration resource.
type KafkaIntegrationArgs struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers pulumi.StringPtrInput
	// Kafka connection string.
	ConnectionString pulumi.StringPtrInput
	// Text describing the integration.
	Description pulumi.StringPtrInput
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat pulumi.StringPtrInput
	// Kafka topics to tail.
	KafkaTopicNames pulumi.StringArrayInput
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig pulumi.StringMapInput
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig pulumi.StringMapInput
	// Use v3 for Confluent Cloud.
	UseV3 pulumi.BoolPtrInput
	// Wait until the integration is active.
	WaitForIntegration pulumi.BoolPtrInput
}

func (KafkaIntegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kafkaIntegrationArgs)(nil)).Elem()
}

type KafkaIntegrationInput interface {
	pulumi.Input

	ToKafkaIntegrationOutput() KafkaIntegrationOutput
	ToKafkaIntegrationOutputWithContext(ctx context.Context) KafkaIntegrationOutput
}

func (*KafkaIntegration) ElementType() reflect.Type {
	return reflect.TypeOf((**KafkaIntegration)(nil)).Elem()
}

func (i *KafkaIntegration) ToKafkaIntegrationOutput() KafkaIntegrationOutput {
	return i.ToKafkaIntegrationOutputWithContext(context.Background())
}

func (i *KafkaIntegration) ToKafkaIntegrationOutputWithContext(ctx context.Context) KafkaIntegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaIntegrationOutput)
}

// KafkaIntegrationArrayInput is an input type that accepts KafkaIntegrationArray and KafkaIntegrationArrayOutput values.
// You can construct a concrete instance of `KafkaIntegrationArrayInput` via:
//
//	KafkaIntegrationArray{ KafkaIntegrationArgs{...} }
type KafkaIntegrationArrayInput interface {
	pulumi.Input

	ToKafkaIntegrationArrayOutput() KafkaIntegrationArrayOutput
	ToKafkaIntegrationArrayOutputWithContext(context.Context) KafkaIntegrationArrayOutput
}

type KafkaIntegrationArray []KafkaIntegrationInput

func (KafkaIntegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KafkaIntegration)(nil)).Elem()
}

func (i KafkaIntegrationArray) ToKafkaIntegrationArrayOutput() KafkaIntegrationArrayOutput {
	return i.ToKafkaIntegrationArrayOutputWithContext(context.Background())
}

func (i KafkaIntegrationArray) ToKafkaIntegrationArrayOutputWithContext(ctx context.Context) KafkaIntegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaIntegrationArrayOutput)
}

// KafkaIntegrationMapInput is an input type that accepts KafkaIntegrationMap and KafkaIntegrationMapOutput values.
// You can construct a concrete instance of `KafkaIntegrationMapInput` via:
//
//	KafkaIntegrationMap{ "key": KafkaIntegrationArgs{...} }
type KafkaIntegrationMapInput interface {
	pulumi.Input

	ToKafkaIntegrationMapOutput() KafkaIntegrationMapOutput
	ToKafkaIntegrationMapOutputWithContext(context.Context) KafkaIntegrationMapOutput
}

type KafkaIntegrationMap map[string]KafkaIntegrationInput

func (KafkaIntegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KafkaIntegration)(nil)).Elem()
}

func (i KafkaIntegrationMap) ToKafkaIntegrationMapOutput() KafkaIntegrationMapOutput {
	return i.ToKafkaIntegrationMapOutputWithContext(context.Background())
}

func (i KafkaIntegrationMap) ToKafkaIntegrationMapOutputWithContext(ctx context.Context) KafkaIntegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaIntegrationMapOutput)
}

type KafkaIntegrationOutput struct{ *pulumi.OutputState }

func (KafkaIntegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KafkaIntegration)(nil)).Elem()
}

func (o KafkaIntegrationOutput) ToKafkaIntegrationOutput() KafkaIntegrationOutput {
	return o
}

func (o KafkaIntegrationOutput) ToKafkaIntegrationOutputWithContext(ctx context.Context) KafkaIntegrationOutput {
	return o
}

// The Kafka bootstrap server url(s). Required only for V3 integration.
func (o KafkaIntegrationOutput) BootstrapServers() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringPtrOutput { return v.BootstrapServers }).(pulumi.StringPtrOutput)
}

// Kafka connection string.
func (o KafkaIntegrationOutput) ConnectionString() pulumi.StringOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringOutput { return v.ConnectionString }).(pulumi.StringOutput)
}

// Text describing the integration.
func (o KafkaIntegrationOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
func (o KafkaIntegrationOutput) KafkaDataFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringPtrOutput { return v.KafkaDataFormat }).(pulumi.StringPtrOutput)
}

// Kafka topics to tail.
func (o KafkaIntegrationOutput) KafkaTopicNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringArrayOutput { return v.KafkaTopicNames }).(pulumi.StringArrayOutput)
}

// Unique identifier for the integration. Can contain alphanumeric or dash characters.
func (o KafkaIntegrationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Kafka configuration for schema registry. Required only for V3 integration.
func (o KafkaIntegrationOutput) SchemaRegistryConfig() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringMapOutput { return v.SchemaRegistryConfig }).(pulumi.StringMapOutput)
}

// Kafka security configurations. Required only for V3 integration.
func (o KafkaIntegrationOutput) SecurityConfig() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.StringMapOutput { return v.SecurityConfig }).(pulumi.StringMapOutput)
}

// Use v3 for Confluent Cloud.
func (o KafkaIntegrationOutput) UseV3() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.BoolPtrOutput { return v.UseV3 }).(pulumi.BoolPtrOutput)
}

// Wait until the integration is active.
func (o KafkaIntegrationOutput) WaitForIntegration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KafkaIntegration) pulumi.BoolPtrOutput { return v.WaitForIntegration }).(pulumi.BoolPtrOutput)
}

type KafkaIntegrationArrayOutput struct{ *pulumi.OutputState }

func (KafkaIntegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KafkaIntegration)(nil)).Elem()
}

func (o KafkaIntegrationArrayOutput) ToKafkaIntegrationArrayOutput() KafkaIntegrationArrayOutput {
	return o
}

func (o KafkaIntegrationArrayOutput) ToKafkaIntegrationArrayOutputWithContext(ctx context.Context) KafkaIntegrationArrayOutput {
	return o
}

func (o KafkaIntegrationArrayOutput) Index(i pulumi.IntInput) KafkaIntegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KafkaIntegration {
		return vs[0].([]*KafkaIntegration)[vs[1].(int)]
	}).(KafkaIntegrationOutput)
}

type KafkaIntegrationMapOutput struct{ *pulumi.OutputState }

func (KafkaIntegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KafkaIntegration)(nil)).Elem()
}

func (o KafkaIntegrationMapOutput) ToKafkaIntegrationMapOutput() KafkaIntegrationMapOutput {
	return o
}

func (o KafkaIntegrationMapOutput) ToKafkaIntegrationMapOutputWithContext(ctx context.Context) KafkaIntegrationMapOutput {
	return o
}

func (o KafkaIntegrationMapOutput) MapIndex(k pulumi.StringInput) KafkaIntegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KafkaIntegration {
		return vs[0].(map[string]*KafkaIntegration)[vs[1].(string)]
	}).(KafkaIntegrationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaIntegrationInput)(nil)).Elem(), &KafkaIntegration{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaIntegrationArrayInput)(nil)).Elem(), KafkaIntegrationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaIntegrationMapInput)(nil)).Elem(), KafkaIntegrationMap{})
	pulumi.RegisterOutputType(KafkaIntegrationOutput{})
	pulumi.RegisterOutputType(KafkaIntegrationArrayOutput{})
	pulumi.RegisterOutputType(KafkaIntegrationMapOutput{})
}
